---
description: NestJS 后端开发规范（响应、异常、错误工具、DTO、Repository、事务、Controller、测试、性能、安全、多租户、Client 与能力域模块划分）
globs: apps/backend/**/*.ts
alwaysApply: false
---

# NestJS 后端开发规范

编辑 `apps/backend` 时遵循。**参考：`apps/backend/src/module/admin/system/user`**。

## 📦 1. 统一响应 API

```typescript
return Result.ok(data);
return Result.ok(data, '操作成功');
return Result.ok({ rows, total }); // 分页
return Result.fail(ResponseCode.BUSINESS_ERROR, '错误信息');
throw new BusinessException(ResponseCode.BUSINESS_ERROR, '非法操作');
BusinessException.throwIf(condition, '错误信息');
```

## 🚨 2. 异常处理

```typescript
import { BusinessException } from 'src/common/exceptions';
BusinessException.throwIfNull(user, '用户不存在');
BusinessException.throwIf(age < 18, '未成年');
```

### 2.1 catch 中安全获取错误信息（必做）

`catch (error)` 的 `error` 为 `unknown` 类型，禁止直接访问 `error.message` / `error.stack`。统一使用 `src/common/utils/error`：

```typescript
import { getErrorMessage, getErrorStack, getErrorInfo } from 'src/common/utils/error';

try {
  // ...
} catch (error) {
  // 仅需 message
  this.logger.error('操作失败:', getErrorMessage(error));

  // 需 message + stack 打日志
  const { message, stack } = getErrorInfo(error);
  this.logger.error(message, stack);

  // 抛给上游
  throw new BusinessException(ResponseCode.BUSINESS_ERROR, getErrorMessage(error));
}
```

| 函数 | 用途 |
|------|------|
| `getErrorMessage(error)` | 安全提取错误文案（Error / 带 message 对象 / 其他） |
| `getErrorStack(error)` | 安全提取 stack，非 Error 返回 undefined |
| `getErrorInfo(error)` | 返回 `{ message, stack? }`，便于 logger.error(msg, stack) |

## 📄 3. DTO 分页（项目标准）

```typescript
export class ListXxxDto extends PageQueryDto {
  @ApiProperty({ required: false })
  @IsOptional()
  @IsString()
  @Length(0, 30)
  userName?: string;

  @ApiProperty({ enum: StatusEnum, required: false })
  @IsOptional()
  @IsEnum(StatusEnum)
  @Transform(({ value }) => (value === '0' ? StatusEnum.NORMAL : value === '1' ? StatusEnum.STOP : value))
  status?: StatusEnum;
}
```

Service 使用 `PaginationHelper.getPagination`、`buildDateRange`、`buildStringFilter`、`paginateWithTransaction`。分页深度限制 offset ≤ 5000（超限抛错）。

## 🏗️ 4. Repository（项目标准）

```typescript
@Injectable()
export class XxxRepository extends SoftDeleteRepository<SysUser, CreateInput, UpdateInput, Delegate> {
  constructor(prisma: PrismaService, cls: ClsService) {
    super(prisma, cls, 'sysUser', 'userId');
  }
}
```

## 🔄 5. 事务

```typescript
import { Transactional } from 'src/common/decorators/transactional.decorator';
@Transactional()
async create(dto) { ... }
```

## 🎨 6. Controller

```typescript
@ApiTags('模块名')
@Controller('path')
@ApiBearerAuth('Authorization')
export class XxxController {
  @Api({ summary: 'xxx-列表', type: XxxListVo })
  @RequirePermission('system:xxx:list')
  @Get('list')
  findAll(@Query() query: ListXxxDto, @User() user: UserDto) {
    return this.xxxService.findAll(query, user.user);
  }

  @Operlog({ businessType: BusinessType.INSERT })
  @Post()
  create(@Body() dto: CreateXxxDto) {
    return this.xxxService.create(dto);
  }
}
```

装饰器：`@Api`、`@RequirePermission`、`@RequireRole`、`@Operlog`、`@User()`。

## 📂 7. 模块结构

```
xxx/
  dto/  vo/  services/  xxx.repository.ts  xxx.service.ts  xxx.controller.ts  xxx.module.ts
```

## 📊 8. 最佳实践

| 维度 | 坏习惯       | 最佳实践         |
| ---- | ------------ | ---------------- |
| 逻辑 | 层层 if-else | 卫语句、策略模式 |
| 代码 | 魔法值       | 枚举             |
| 事务 | 事务里调 RPC | 事务仅包裹 DB    |
| DB   | 循环查库 N+1 | Where IN 批量    |

---

## 🧪 9. 测试规范（必做）

写完一个模块/功能后必须补充测试：

- **单元测试**：Service、工具函数、核心业务逻辑须有对应 `*.spec.ts`，覆盖主路径与关键边界、异常分支。
- **联合/集成测试**：涉及多模块协作、数据库或外部依赖的流程，在 `test/` 下编写 e2e 或 integration 测试（如 `xxx-flow.e2e-spec.ts`、`integration/xxx.spec.ts`）。

| 类型          | 放置位置                                  | 适用场景                                     |
| ------------- | ----------------------------------------- | -------------------------------------------- |
| 单元测试      | 与源文件同目录 `xxx.spec.ts`              | Service 方法、Repository、工具函数、业务规则 |
| 集成/联合测试 | `test/integration/`、`test/*.e2e-spec.ts` | 多模块联调、完整业务流程、数据库+外部依赖    |

PR 时新逻辑应有对应单测或集成测试，核心/资金类逻辑建议二者兼备。

---

## 🚀 10. 接口与大表性能规范（PR 必答）

**原则**：接口要对「数据增长 + 访问增长」负责。

### 10.1 设计三问

1. 会不会高频访问？2. 会不会访问大表？3. 数据/QPS 翻 10 倍是否可控？

### 10.2 QPS 分级（按档位评估即可）

| 档位 | QPS      | 典型           | 要求                           |
| ---- | -------- | -------------- | ------------------------------ |
| 低   | < 20     | 后台、配置     | 简单查询可接受                 |
| 中   | 20 ~ 200 | 列表、详情     | 命中索引、评估缓存、禁止深分页 |
| 高   | > 200    | 首页、核心链路 | 必须缓存/读模型、水平扩展      |

**必评估 QPS**：大表、流水、订单、日志、高频列表。其余可默认「低」。

### 10.3 大表名单（默认按大表设计）

订单、流水（支付/钱包/积分）、操作日志、明细表、历史表、消息表。

### 10.4 数据量级

| 级别 | 数据量           | 要求                              |
| ---- | ---------------- | --------------------------------- |
| D1   | < 10 万          | offset 分页可接受                 |
| D2   | 10 万 ~ 100 万   | 索引、禁止全表扫描                |
| D3   | 100 万 ~ 1000 万 | 禁止 offset > 5000、游标/时间分页 |
| D4   | > 1000 万        | 分表、读写分离、ES、归档          |

### 10.5 禁止项

- offset > 5000
- order by 非索引字段
- 大表 `like %xxx%`（buildStringFilter 用 contains，大表慎用）
- 单接口返回 > 1000 条（导出须分页或异步）

### 10.6 流水表

只允许 insert，禁止 update/delete。查询必须带时间范围。如需状态修正，仅允许新增「状态/修正原因」等审计字段，禁止改金额等核心字段。

### 10.7 升级红线

单表 > 500 万、QPS > 200、P95 > 500ms、全表扫描、offset > 5000。

### 10.8 PR 必答

- QPS 档位（低/中/高）
- 是否大表
- 数据量预估
- 是否命中索引 / 深分页
- 翻 10 倍后的升级方案

---

## 🛡️ 11. 安全与稳定性规范

### 11.1 幂等性（P0）

支付/下单/创建类接口必须幂等。实现：唯一约束、Redis SetNX、分布式锁、状态机。

### 11.2 防重复提交（P0）

表单/下单等短时拦截。后端 Redis 记录 `userId+业务key`，TTL 3–5 秒。

### 11.3 敏感数据脱敏（P0）

日志和接口返回禁止明文：手机号、身份证、银行卡、密码。脱敏示例：`138****1234`。

### 11.4 限流（P1）

高 QPS 接口必须限流。维度：IP、用户、接口。实现：令牌桶、Nginx、Gateway、Redis。

### 11.5 调用超时与弱依赖（P1）

RPC/HTTP 必须设超时（如 3–5s）。非核心依赖做弱依赖：超时/失败不影响主流程。

### 11.6 熔断与降级（P2）

下游异常/超时比例高时熔断。降级：默认值、缓存、简化逻辑。重点：支付、短信、第三方 API。

### 11.7 错误信息隐藏（P1）

生产环境不向前端返回堆栈、SQL、内部路径。统一错误码 + 通用文案，详情写日志。

### 11.8 参数白名单（P2）

orderBy、where 条件白名单，禁止前端随意传入任意字段。防注入、控性能。

### 11.9 签名防篡改（P2）

金额等关键字段签名（参数+时间戳+密钥）。支付/资金类接口建议使用。

### 11.10 可观测性（P3）

核心接口监控：QPS、P95 耗时、错误率。日志含 traceId、userId、关键参数（脱敏）。

---

## 🏢 12. 多租户与接口分类

Backend 同时服务 **Admin 后台**（system/*）与 **Miniapp 小程序**（client/*）。接口分为「按租户隔离」与「不按租户隔离」两类，新增/修改接口时必须先区分并标明。

### 12.1 三种接口类型

| 类型 | 说明 | 示例 |
|------|------|------|
| **TenantScoped** | 数据按当前租户隔离；租户来自请求头 `tenant-id` 或登录态；Repository 用 BaseRepository/SoftDeleteRepository 自动过滤。 | 用户/角色/部门列表；小程序的订单、购物车、商品、钱包。 |
| **PlatformOnly** | 不按租户隔离，仅平台或超管可调；必须配 `RequirePermission` 或角色校验。 | 租户管理、租户套餐、同步字典、监控。 |
| **TenantAgnostic** | 不依赖当前登录租户；租户由参数或返回值决定。 | `client/location/match-tenant`、`nearby-tenants`。 |

### 12.2 路径与调用方约定

- **system/tenant、system/tenant-package** → 一律 **PlatformOnly**。
- **client/location** 下「根据坐标/位置解析或列出租户」的接口 → **TenantAgnostic**。
- **client/** 下订单、购物车、商品、钱包等 → **TenantScoped**（租户来自 header 或 body，与前端约定一致）。
- **system/** 下其余业务（用户、角色、部门等）→ **TenantScoped**。

### 12.3 标明方式（必做）

- 在 Controller 类或方法上用 JSDoc 标明：`/** @tenantScope TenantScoped */` 或 `PlatformOnly` 或 `TenantAgnostic`。
- 与路径约定不一致时必须在类或方法上显式注释。

### 12.4 新增接口前自检

1. 主要调用方：admin / miniapp / both？
2. 是否按租户隔离？→ 是则 TenantScoped，否则 PlatformOnly 或 TenantAgnostic。
3. PlatformOnly 是否已加权限？
4. Miniapp 且 TenantScoped 时，租户来源是 header 还是 body/query？在注释或文档写明。

### 12.5 数据层要求

- 租户内接口：访问租户隔离表必须通过继承 BaseRepository/SoftDeleteRepository 的 Repository；禁止手写 `prisma.xxx.findMany()` 且不加租户条件（除非显式跨租户且已加权限）。
- 创建租户隔离数据：禁止由前端传入 `tenantId` 落库；从 `TenantContext.getTenantId()` 或 `this.cls.get('tenantId')` 取。
- 跨租户/平台查询：用项目约定的忽略租户机制（如 TenantContext.run + setIgnoreTenant），并做权限校验。

---

## 📁 13. Client 与能力域模块职责划分

**通用原则**：`client` 目录 = 小程序 C 端接口全集；能力域目录 = Service、Repository、规则配置，仅通过 admin 暴露配置接口，C 端能力由 `client` 薄 Controller 调用。

### 13.1 通用职责约定

| 角色 | 目录 | 职责 | 路径约定 |
|------|------|------|----------|
| **Client** | `module/client/` | 所有 `client/*` 的 Controller，包含各能力域的 C 端接口（薄 Controller，调用能力域 Service） | `client/*` |
| **能力域** | `module/{domain}/` | Service、Repository、规则配置；仅提供 `admin/{domain}/*` 配置接口；**禁止**直接暴露 `client/*` | `admin/{domain}/*` |

适用于：marketing、finance、store 等可被 C 端调用的能力域。依赖方向：`client` → 能力域，**禁止**能力域 → client。

### 13.2 强制规则（通用）

- **client 下必须包含**：所有 `client/*` 路径的 Controller，包括各能力域的 C 端接口。
- **能力域下禁止**：直接使用 `@Controller('client/*')`。C 端能力通过 Service 对外提供，由 `module/client/{domain}/` 的 Controller 调用。
- **依赖方向**：`client` → 能力域，禁止能力域依赖 client。

### 13.3 能力域清单与路径（按需扩展）

| 能力域 | 目录 | admin 路径 | client 子路径 |
|--------|------|------------|---------------|
| Marketing | `module/marketing/` | `admin/marketing/*` | `client/marketing/*` |
| （未来可扩展 finance、wallet 等） | — | — | — |

### 13.4 以 Marketing 为例的目录结构

```
module/client/
├── auth/          # 登录、会员认证
├── user/          # 用户信息
├── order/         # 订单
├── cart/          # 购物车
├── product/       # 商品
├── marketing/     # C 端营销接口（薄 Controller，调用 marketing Service）
│   ├── coupon/    # 领券、我的优惠券
│   └── points/    # 签到、积分账户、积分任务
├── ...
└── client.module.ts

module/marketing/
├── coupon/        # 优惠券 Service、Repository、admin 配置接口
├── points/        # 积分 Service、Repository、admin 配置接口
├── integration/   # 订单优惠计算 Service（供 order 调用）
└── ...
```

### 13.5 新增 C 端能力域接口时（通用流程）

1. 在 `module/client/{能力域}/` 下新增或扩展 Controller。
2. 注入并调用对应能力域模块导出的 Service。
3. 路径使用 `client/{能力域}/xxx`，守卫使用 `MemberAuthGuard`，装饰器使用 `@Member()`。

### 13.6 Marketing 迁移指引

若当前 C 端营销接口仍在 `module/marketing` 中，需按 **`docs/CLIENT_MARKETING_MIGRATION_SPEC.md`** 执行迁移，使结构符合本节约定。
