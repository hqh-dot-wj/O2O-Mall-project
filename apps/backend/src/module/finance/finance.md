# 财务总览模块 (Finance Module) 技术文档

---

### 📂 1. 模块组织架构 (Architecture Overview)

财务模块采用“分离式生命周期”设计，将资金从产生的那一刻到流出的过程划分为四个职责明晰的子模块：

```text
finance/
├── commission/     # 【产生层】分佣策略算法、自购检测、黑名单校验、异步生成冻结佣金
├── settlement/    # 【流转层】定时任务扫描、解冻保护期校验、资金入账钱包
├── wallet/        # 【余额层】核心资产存储、乐观锁并发控制、全量账务流水(审计源)
└── withdrawal/    # 【流出层】提现申请校验、人工/自动审核、三方支付渠道(微信)对接
```

---

### 🗄️ 2. 数据库表与资金链路 (Database & Fund Flow)

财务模块通过物理表的状态机转换，实现了资金“全生命周期”的追溯：

| 阶段 | 核心表 | 状态转换与逻辑 |
| :--- | :--- | :--- |
| **产生** | `fin_commission` | `支付成功` ➔ `FROZEN` (记录受益人、金额、预计解冻时间)。 |
| **结算** | `fin_wallet` | `到期扫描` ➔ `SETTLED` (佣金状态) ➔ `balance++` (钱包可用余额)。 |
| **留痕** | `fin_transaction` | `WALLET_IN` (入账流水) / `CONSUME_OUT` (消费流水)。唯一流水 ID。 |
| **流出** | `fin_withdrawal` | `提现申请` ➔ `PENDING` (余额冻结) ➔ `APPROVED` (外部打款/扣除冻结)。 |

**全链路闭环：**
`订单 (OMS)` ➔ `佣金计算 (Commission)` ➔ `结算解冻 (Settlement)` ➔ `可用余额 (Wallet)` ➔ `提现/消费 (Withdrawal/Pay)`。

---

### 🔌 3. 技术关键词与核心闭环 (Stack & Closure)

#### **3.1 异步驱动与性能解耦**
*   **关键词**：`BullMQ`, `Event-Driven`
*   **闭环方案**：分佣计算不占用支付回调时间。通过消息队列异步处理复杂的推荐链逻辑，保障交易主流程的高可用。

#### **3.2 强一致性账务处理**
*   **关键词**：`@Transactional`, `Atomic Increment`, `Optimistic Locking`
*   **闭环方案**：所有涉及余额变动的操作均包裹在底层的原子事务中。使用“先流转状态，后变动现金”的原则，确保财务账目的幂等性与可回滚性。

#### **3.3 审核与副作用隔离**
*   **关键词**：`External RPC Isolation`
*   **闭环方案**：提现审核将“本地事务”与“外部 API 调用”物理隔离。确保支付引擎打款状态未知时，本地账目不会发生逻辑错位。

---

### 🛡️ 4. 全局安全审计 (Finance-Wide Audit)

#### **4.1 系统性“坏账”风险扫描**
*   **资产负债失衡**：如果 `fin_commission` 的总和不等于 `Order.total_amount * Ratio`。
*   **防御**：在业务层引入“分佣上限熔断”逻辑。单个订单产生的总佣金绝不允许超过订单实付金额的一定比例（如 50%）。

#### **4.2 跨租户数据泄露 (Multi-Tenant Safety)**
*   **风险**：租户 A 的佣金结算到了租户 B 的用户钱包中。
*   **审计**：系统在 `WalletService` 和 `CommissionService` 中强制校验 `beneficiary.tenantId` 与 `order.tenantId`（除非开启跨店分销）。
*   **加固**：在 Repository 层应用全局拦截器，强制在所有财务查询中注入 `tenantId` 条件。

#### **4.3 高并发下的余额“爆仓”防御**
*   **风险**：提现申请与佣金结算并发时，由于读写分离或缓存延迟导致余额错乱。
*   **方案**：放弃缓存余额作为校验基准。所有的提现、加钱操作必须基于数据库 `SELECT FOR UPDATE` 或 `Atomic Update`。

#### **4.4 财务精度累积误差**
*   **风险**：大规模交易下，分厘进位导致的“几分钱”差错导致总账不平。
*   **方案**：数据库底层统一采用 `Decimal(12, 2)`。内部中间计算保留 4 位精度，仅在最终入账时执行舍入。建议周期性执行 `Sum(Wallet) + Sum(Frozen) == Sum(Transaction)` 的全局自动对账任务。
