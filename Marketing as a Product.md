# 营销玩法商品化平台 PRD (MaaS Platform v2.0)

## 1. 核心理念与架构

### 1.1 核心变革

从“创建一次性活动”转型为**“生产营销商品”**。

* **旧模式**：运营填写一堆表单，创建一个独立的拼团活动。
* **新模式**：运营选择一个现有的服务（如舞蹈课），套用一个“拼团策略”，生成一个“拼团版舞蹈课”进行售卖。

### 1.2 角色与职责三层模型

| 角色 | 动作 | 产出物 | 职责边界 |
| --- | --- | --- | --- |
| **总部 (HQ)** | 定义玩法模板 | `PlayTemplate` | 定义代码逻辑、规则结构 (Schema)、通用 UI 组件。 |
| **门店 (Store)** | 配置营销商品 | `StorePlayConfig` | 选品 (SKU)、定价、定库存、配规则 (如仅限新人)。 |
| **消费者 (User)** | 消费玩法实例 | `PlayInstance` | 发起拼团、参与砍价、支付订单。 |

---

## 2. 核心领域模型设计 (Data Model)

### 2.1 营销侧模型 (Marketing Side)

* **PlayTemplate (总部)**：
  * `code`: "GROUP_BUY"
  * `ruleSchema`: 定义这就玩法需要配置哪些参数（如成团人数、倒计时）。
  * `unitName`: 动态单位（如 "节"、"小时"、"袋"）。

* **StorePlayConfig (门店)**：
  * `serviceId`: 关联物理服务（如 "舞蹈课"）。
  * `rules`: `{ target: 10, region: "Beijing", allow: "NEW_USER" }`。

* **PlayInstance (实例/交易载体)**：
  * `status`: **唯一真理状态** (PENDING / ACTIVE / SUCCESS / FAILED)。
  * `progress`: `{ current: 5, target: 10 }`。

### 2.2 履约侧模型 (Fulfillment Side) —— *新增*

*这是实现“活动效果追踪”的关键。*

* **Order (订单)**：
  * `sourceInstanceId`: **必须透传**（如 `GROUP_2026_CNY`）。

* **UserAsset (用户资产/权益)**：
  * `assetType`: "COURSE" | "SERVICE" | "GOODS"
  * `totalAmount`: 20
  * `remainingAmount`: 20
  * `sourceActivityId`: **标记资产来源**（关联到具体营销活动）。

* **ConsumptionLog (核销流水)**：
  * 记录每次扣减的资产 ID 及其对应的 `sourceActivityId`。

---

## 3. 规则生效体系 (Rule System)

规则分为三层漏斗，在不同阶段生效：

1. **可见性规则 (Visibility)** —— *查询阶段*
   * **逻辑**：SQL/ES 过滤。
   * **场景**：仅当前门店可见、仅特定城市可见。
   * **实现**：`GET /instances?storeId=1001&city=BJ`。

2. **状态硬性规则 (Status)** —— *展示阶段*
   * **逻辑**：前端根据 `status` 和 `progress` 渲染。
   * **场景**：活动未开始、人数已满、时间截止。
   * **前端交互**：
     * 若 `now > endTime`：按钮置灰，显示“已结束”。
     * 若 `current >= max`：按钮置灰，显示“名额已满”。

3. **业务准入规则 (Eligibility)** —— *交易阶段*
   * **逻辑**：后端规则引擎拦截。
   * **场景**：仅限新用户、每人限购 1 份。
   * **实现**：点击“立即参团”时，后端校验并抛出异常。

---

## 4. 通用活动效果分析报表 (Dashboard)

前端基于**卡片式架构**开发，后端返回标准化数据结构。

### 4.1 核心指标定义

无论活动是卖米（实物）还是卖课（服务），统一归一化为以下字段：

* `TotalAssetPool` (总权益池)：售出份数 × 每份包含的数量。
* `ConsumedAsset` (已核销权益)：实际履约数量。
* `Unit` (单位)：从 Template 中读取。

### 4.2 报表 UI 结构

1. **漏斗卡片**：浏览 -> 参与/发起 -> 支付/成交。
2. **营收卡片**：GMV (总金额)、售出份数 (Order Count)。
3. **履约进度卡片 (核心)**：
   * 展示进度条：`已核销 {consumed} {unit} / 总计 {total} {unit}`。
   * 示例 A (保洁)：已核销 **90 小时** / 总计 **150 小时**。
   * 示例 B (大米)：已核销 **180 袋** / 总计 **200 袋**。

4. **特色指标区 (动态插件)**：
   * 拼团：显示“成团率”。
   * 老带新：显示“裂变系数”。

---

## 5. 研发实施阶段 (Roadmap)

* **M1：商品化模型构建**
  * 完成 HQ 模板定义与 Store 配置后台。
  * 实现“服务”到“营销商品”的转化逻辑。

* **M2：交易与状态机**
  * 实现拼团核心流程。
  * **重点**：前端只读 Status，后端处理高并发状态流转。

* **M3：履约与追踪**
  * 打通订单 -> 资产 -> 核销的 ID 透传链路。
  * 上线通用报表前端组件。

## 6. 系统稳定性与风控体系 (Stability & Risk Control)

### 6.1 核心风险防御
1.  **超卖防御 (Redis Pre-decrement)**
    *   **机制**：不等待支付成功，点击“抢购”即在 Redis 扣减库存。
    *   **流程**：Redis decr -> 成功则锁定库存唤起支付 -> 5分钟未支付 Redis incr 回滚。
    *   **价值**：消除“支付后被退款”的糟糕体验。

2.  **流量雪崩防御**
    *   **读写分离**：C端读取走缓存，写入走 MQ。
    *   **削峰填谷**：订单创建请求直接入 MQ，后端异步处理。
    *   **前端防抖**：按钮点击即 Disabled。

3.  **边界异常处理**
    *   **退款死循环**：异步任务 + 指数退避重试 (Immediate -> 1m -> 1h -> Alert)。

### 6.2 缺失模块补完
1.  **风控黑名单 (Risk Control)**
    *   限制同 IP/同设备 ID 请求频率。
    *   拦截新注册无资料账号参与秒杀。
2.  **互斥规则引擎 (Conflict Mutex)**
    *   时间冲突校验：同一时段不能参与两个互斥的服务类活动。
3.  **幂等性 (Idempotency)**
    *   基于前端生成的唯一 `request_id` 进行防重。
4.  **资金对账 (Reconciliation)**
    *   每日凌晨自动比对系统订单与微信账单。

## 7. 技术实现决策 (Technical Decisions)

*   **后台预览方案**：**Iframe 嵌入** (真实还原，低成本)。
*   **后端选型**：**NestJS** (符合团队现状，利用 Redis Lua 处理并发)。
*   **分账方案**：**门店提现审核制 (Settlement Application)**。
    *   门店发起结算申请 -> 总部财务审核 -> 审核通过后系统批量触发微信分账。
