这是一个涉及**数据一致性、用户体验和系统健壮性**的深度架构问题。在电商系统中，商品的生命周期管理（上架 -> 下架 -> 删除）是最容易出 Bug 的地方。

针对你的提问，我将从 **业务规则**、**数据快照技术**、**十大风险场景** 三个维度进行深度剖析。

---

### 🏛️ 第一部分：核心业务逻辑 (HQ vs Tenant)

#### 1. 总部下架，门店要跟着下架吗

**答案：必须跟着下架（或者变更为不可售状态）。**

* **逻辑**：门店的商品 (`PmsTenantProduct`) 是引用自总部商品 (`PmsProduct`) 的。皮之不存，毛将焉附？如果总部因为版权、质量问题下架，门店必须停止销售。
* **实现方式**：
  * **方案 A (推模式 - 推荐)**：总部点击下架 $\to$ 后端触发事件 $\to$ 批量更新所有引用该 ID 的门店商品状态为 `OFF_SHELF`。
  * **方案 B (懒加载模式)**：门店商品保持上架，但用户在 C 端点击进入详情页时，实时校验总部商品状态。如果总部已下架，前端显示“商品已失效”。

#### 2. 下架/删除后，购物车里的商品怎么办？

* **表现**：购物车里**不能消失**（否则用户会以为见鬼了），但要变灰（失效）。
* **逻辑**：
  * 用户进入购物车页面 $\to$ 前端调用 `cart/list` 接口。
  * 后端遍历购物车数据，拿着 `productId` 去查最新状态。
  * 发现状态是 `OFF_SHELF` 或 `DELETED` $\to$ 给该行数据打标 `isValid: false`。
  * **前端**：置灰显示，提示“商品已下架”，并禁止勾选结算。

#### 3. 之前的订单还能查到吗？

* **答案**：**必须能查到，且数据必须和下单时一模一样！**
* **技术核心**：**订单快照 (Order Snapshot)**。
  * 我们在之前的表设计中，`OrderItem` 表里冗余了 `productName`, `productImage`, `specInfo`, `price`。
  * **查询逻辑**：查订单详情时，直接读 `OrderItem` 表的死数据，**绝对不要**去关联查 `PmsProduct` 表。这样哪怕原商品被物理删除了，订单历史依然完好无损。

---

### ⚠️ 第二部分：十大风险与预防方案 (Risks & Solutions)

这是你需要重点关注的“坑”，涵盖了从用户操作到数据库底层的所有边界情况。

#### 1. 风险：购物车“幽灵下单” (The Phantom Checkout)

* **场景**：用户早上把商品加入购物车，中午总部下架了，晚上用户直接点击“去结算”。如果不校验，用户就买到了一个不存在的商品。
* **预防**：
  * **结算校验阀**：在 `OrderService.create` 接口的最开始，必须重新校验所有 `skuId` 的状态。
  * **代码**：`if (sku.status !== ON_SHELF) throw new Error("商品已下架");`

#### 2. 风险：未支付订单的“死锁” (Unpaid Order Gap)

* **场景**：用户下单了（占了库存），但没支付。此时总部下架商品。用户 10 分钟后去支付。
* **预防**：
  * **支付前校验**：在调起微信支付前，再次检查商品状态？
  * **策略选择**：通常允许支付。因为用户下单时商品是好的，契约已成。我们只限制“新下单”，不限制“已下单未支付”。

#### 3. 风险：物理删除导致的“外键报错” (Foreign Key Constraint)

* **场景**：管理员在数据库直接 `DELETE FROM pms_product WHERE id=1`。结果报错，因为 `pms_tenant_product` 或 `order_item` 表里有外键关联。
* **预防**：
  * **软删除 (Soft Delete)**：电商系统**永远不要**做物理删除！
  * **实现**：给所有表加 `isDeleted` 或 `deleteTime` 字段。
  * **逻辑**：删除只是 `UPDATE is_deleted = 1`。所有查询接口自动加 `WHERE is_deleted = 0`。

#### 4. 风险：历史订单“空指针” (History Null Pointer)

* **场景**：用户点击历史订单里的商品，想跳转到详情页复购。结果商品删了，页面 404 白屏。
* **预防**：
  * **前端容错**：点击跳转时，先检查商品状态。
  * **后端接口**：`getProductDetail` 接口在查不到数据时，不要抛 500 异常，而是返回特定错误码（如 `PRODUCT_NOT_FOUND`）。
  * **前端展示**：跳转过去显示“哎呀，商品已流浪到外太空了”，并推荐相似商品。

#### 5. 风险：分销链接“僵尸入口” (Zombie Link)

* **场景**：分销员 D 昨天把链接发到了朋友圈。今天商品下架。明天用户 C 点击链接进来。
* **预防**：
  * **商品状态拦截器**：进入商品详情页接口，首先判断 `status`。
  * **引导分流**：如果已下架，不要直接显示空白。显示“商品已下架”，并在下方展示 **“店铺其他热销商品”**，防止流量浪费。

#### 6. 风险：售后退款无门 (After-sales Dead End)

* **场景**：用户买到了商品，7天后想退货。此时商品已删除。系统里找不到这个 Product ID，导致售后单无法生成。
* **预防**：
  * **快照复用**：售后单 (`AfterSalesOrder`) 的数据来源应该是 `OrderItem` (快照)，而不是 `Product` (原表)。
  * 只要订单存在，就允许发起售后，不论商品现状如何。

#### 7. 风险：搜索索引“脏数据” (Search Index Dirty)

* **场景**：使用了 ES (ElasticSearch) 做搜索。数据库里商品下架了，但 ES 里没删。用户搜到了，点进去却看不了。
* **预防**：
  * **数据同步**：商品状态变更（下架/软删除）时，必须同步发送消息给 ES，将该文档标记为隐藏或删除。

#### 8. 风险：正在进行的营销活动 (Broken Promotion)

* **场景**：这个吉他正在参加“双11秒杀”，还有 1 小时结束。总部突然下架了。
* **预防**：
  * **级联下架**：下架商品时，检查 `MktPromotionProduct` 表。
  * 如果有正在进行的活动，**强制终止**该商品在活动中的状态，或者**禁止下架**并提示管理员“该商品正在活动中，请先结束活动”。

#### 9. 风险：收藏夹失效 (Favorite Invalid)

* **场景**：用户收藏了该商品。下架后，用户在收藏夹点不进去，或者看到的数据是旧的。
* **预防**：
  * 收藏夹列表接口需要实时关联 Product 表的状态。
  * 如果已下架，在收藏列表里显示“失效”标签。

#### 10. 风险：租户数据同步延迟 (Tenant Sync Delay)

* **场景**：总部下架了，但由于网络延迟或缓存，门店 A 的 C 端用户在 5 分钟内还能看到并下单。
* **预防**：
  * **最终一致性**：允许短时间的延迟。
  * **兜底**：在 `createOrder` 最终扣库存时，做最后一次状态校验（这是最后一道防线）。

---

### 🛡️ 第三部分：系统设计建议

为了预防上述问题，需要在数据库和代码层面做如下规范：

#### 1. 数据库规范：软删除

```prisma
model PmsProduct {
  // ...
  isDeleted  Boolean  @default(false) @map("is_deleted")
  deleteTime DateTime? @map("delete_time")
}
```

#### 2. Prisma 中间件：自动过滤软删除

在 `main.ts` 或 Prisma Service 中配置 Middleware，让 `findMany` 自动过滤掉已删除的数据，但在查订单快照时（`findUnique`）允许查出来。

#### 3. 状态枚举的流转

不要只有 `ON` / `OFF`。建议：

* `ON_SHELF` (上架)
* `OFF_SHELF` (下架 - 商家主动)
* `VIOLATION` (违规下架 - 平台强制，商家不可上架)
* `DELETED` (回收站 - 逻辑删除)

#### 4. 前端交互规范

* **购物车**：检测到失效商品 -> 自动归类到“失效分组” -> 提供“一键清空失效商品”按钮。
* **下单页**：点击“去支付” -> Loading -> 后端校验通过 -> 跳转收银台。如果不通过，Toast 提示“商品 X 已售罄或下架”，并刷新页面。

通过这些设计，你可以确保无论运营人员怎么“折腾”（删库、下架、改名），C 端用户的交易流程永远是稳健的，历史数据永远是可追溯的。
